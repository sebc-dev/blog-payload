/**
 * Template pour les tests d'intÃ©gration de collections Payload CMS
 * 
 * ğŸ“‹ Instructions d'utilisation :
 * 1. Copier ce fichier vers tests/int/collections/{collection}.int.spec.ts
 * 2. Remplacer {Collection} par le nom de votre collection
 * 3. Remplacer {collection} par le slug de votre collection
 * 4. Adapter les champs de donnÃ©es selon votre schÃ©ma
 * 5. Utiliser TOUJOURS createUniqueTestData() pour Ã©viter les conflits
 * 
 * âœ… Pattern validÃ© et testÃ© - Compatible avec Payload CMS 3.x
 * 
 * RÃ©fÃ©rence : docs/rapports/Tests-Integration-Isolation-Solution.md
 */

import { describe, it, expect, beforeAll, afterEach } from 'vitest'
import type { Payload } from 'payload'

import { getPayloadClient } from '../../helpers/payload'
import { createUniqueTestData } from '../../helpers/database-isolation'

describe('Collection {Collection} - Tests d\'intÃ©gration avec isolation', () => {
  let payload: Payload

  beforeAll(async () => {
    payload = await getPayloadClient()
  })

  afterEach(async () => {
    // Nettoyage lÃ©ger - l'utilisation de donnÃ©es uniques Ã©vite la plupart des conflits
    // Ajouter ici un nettoyage spÃ©cifique si nÃ©cessaire
  })

  describe('CrÃ©ation de {collection}', () => {
    it('devrait crÃ©er un {collection} avec des donnÃ©es valides', async () => {
      const unique = createUniqueTestData()
      const data = {
        // ğŸ“ Adapter selon votre schÃ©ma de collection
        name: `Test {Collection} ${unique.name}`,
        // slug: `test-slug-${unique.slug}`, // Si applicable
        // email: unique.email,              // Si applicable
        // ... autres champs
      }

      const result = await payload.create({
        collection: '{collection}',
        data
      })

      // âœ… Assertions standard
      expect(result.id).toBeDefined()
      expect(result.name).toBe(data.name)
      expect(result.createdAt).toBeDefined()
      expect(result.updatedAt).toBeDefined()
      
      // ğŸ“ Ajouter d'autres assertions selon votre schÃ©ma
    })

    it('ne devrait pas crÃ©er un {collection} avec des donnÃ©es invalides', async () => {
      const invalidData = {
        // ğŸ“ DÃ©finir des donnÃ©es invalides selon votre schÃ©ma
        // Par exemple : email invalide, champ requis manquant, etc.
      }

      await expect(
        payload.create({
          collection: '{collection}',
          // @ts-expect-error Testing invalid data
          data: invalidData
        })
      ).rejects.toThrow()
    })

    // ğŸ“ Ajouter d'autres tests de crÃ©ation selon vos besoins
  })

  describe('Recherche de {collection}', () => {
    it('devrait trouver un {collection} par critÃ¨re', async () => {
      const unique = createUniqueTestData()
      const data = {
        name: `Searchable {Collection} ${unique.name}`,
        // ğŸ“ Autres champs selon votre schÃ©ma
      }

      // CrÃ©er l'item
      const created = await payload.create({
        collection: '{collection}',
        data
      })

      // Le rechercher
      const result = await payload.find({
        collection: '{collection}',
        where: {
          name: {
            contains: unique.name // Utilise l'identifiant unique pour la recherche
          }
        }
      })

      expect(result.docs).toHaveLength(1)
      expect(result.docs[0].id).toBe(created.id)
    })

    it('devrait paginer les rÃ©sultats correctement', async () => {
      const unique = createUniqueTestData()
      const items = []

      // CrÃ©er plusieurs items avec des donnÃ©es uniques
      for (let i = 0; i < 3; i++) {
        const data = {
          name: `Paginated Item ${i} ${unique.name}`,
          // ğŸ“ Autres champs selon votre schÃ©ma
        }
        items.push(data)
      }

      // CrÃ©er les items
      for (const item of items) {
        await payload.create({
          collection: '{collection}',
          data: item
        })
      }

      // Tester la pagination
      const result = await payload.find({
        collection: '{collection}',
        where: {
          name: {
            contains: unique.name
          }
        },
        limit: 2,
        page: 1,
        sort: 'name'
      })

      expect(result.docs).toHaveLength(2)
      expect(result.totalDocs).toBe(3)
      expect(result.totalPages).toBe(2)
      expect(result.page).toBe(1)
    })
  })

  describe('Mise Ã  jour de {collection}', () => {
    it('devrait mettre Ã  jour un {collection} existant', async () => {
      const unique = createUniqueTestData()
      const originalData = {
        name: `Original {Collection} ${unique.name}`,
        // ğŸ“ Autres champs selon votre schÃ©ma
      }

      // CrÃ©er l'item
      const created = await payload.create({
        collection: '{collection}',
        data: originalData
      })

      // Le mettre Ã  jour
      const updateData = {
        name: `Updated {Collection} ${unique.name}`,
        // ğŸ“ Autres champs Ã  mettre Ã  jour
      }

      const updated = await payload.update({
        collection: '{collection}',
        id: created.id,
        data: updateData
      })

      expect(updated.name).toBe(updateData.name)
      expect(updated.updatedAt).not.toBe(created.updatedAt)
    })

    // ğŸ“ Ajouter d'autres tests de mise Ã  jour selon vos besoins
  })

  describe('Suppression de {collection}', () => {
    it('devrait supprimer un {collection} existant', async () => {
      const unique = createUniqueTestData()
      const data = {
        name: `To Delete {Collection} ${unique.name}`,
        // ğŸ“ Autres champs selon votre schÃ©ma
      }

      // CrÃ©er l'item
      const created = await payload.create({
        collection: '{collection}',
        data
      })

      // Le supprimer
      await payload.delete({
        collection: '{collection}',
        id: created.id
      })

      // VÃ©rifier qu'il n'existe plus
      const result = await payload.find({
        collection: '{collection}',
        where: {
          id: {
            equals: created.id
          }
        }
      })

      expect(result.docs).toHaveLength(0)
    })

    it('devrait lever une erreur lors de la suppression d\'un {collection} inexistant', async () => {
      await expect(
        payload.delete({
          collection: '{collection}',
          id: 999999 // ID inexistant
        })
      ).rejects.toThrow()
    })
  })

  describe('Validation des donnÃ©es', () => {
    it('devrait accepter des donnÃ©es minimales valides', async () => {
      const unique = createUniqueTestData()
      const minimalData = {
        // ğŸ“ DÃ©finir les donnÃ©es minimales requises selon votre schÃ©ma
        name: `Minimal {Collection} ${unique.name}`
      }

      const result = await payload.create({
        collection: '{collection}',
        data: minimalData
      })

      expect(result.name).toBe(minimalData.name)
      // ğŸ“ VÃ©rifier les valeurs par dÃ©faut selon votre schÃ©ma
    })

    // ğŸ“ Ajouter d'autres tests de validation selon vos rÃ¨gles mÃ©tier
  })

  // ğŸ“ Ajouter d'autres groupes de tests selon les fonctionnalitÃ©s de votre collection :
  // - Tests d'hooks si applicable
  // - Tests de permissions si applicable  
  // - Tests de relations si applicable
  // - Tests de champs spÃ©ciaux (upload, rich text, etc.)
})

/**
 * ğŸ“š Exemples d'adaptation pour diffÃ©rents types de collections :
 * 
 * ğŸ” Collection avec authentification (Users) :
 * - Tester login/logout
 * - Tester les permissions
 * - Utiliser des emails uniques
 * 
 * ğŸ“ Collection avec upload (Media) :
 * - Tester les champs alt/caption
 * - Tester la configuration des tailles d'images
 * - VÃ©rifier les contraintes de validation
 * 
 * ğŸ·ï¸ Collection avec slugs (Posts/Categories/Tags) :
 * - Tester l'auto-gÃ©nÃ©ration des slugs
 * - Tester l'unicitÃ© des slugs
 * - Tester la normalisation des caractÃ¨res spÃ©ciaux
 * 
 * ğŸ”— Collection avec relations :
 * - Tester les rÃ©fÃ©rences entre collections
 * - Tester les contraintes de cascade
 * - Tester les requÃªtes populate
 */